```
import { useState, useEffect, useRef } from 'react'
import { OPUPClient, OpupCmd } from './lib/opup'
import { WebSerialTransport } from './lib/opup/web-transport'
import { HexEditor } from './components/HexEditor'
import { Header } from './components/Header'
import { Sidebar } from './components/Sidebar'
import { Log } from './components/Log'
import { AVRFuseEditor } from './components/AVRFuseEditor'
import { ChipDef, CHIP_DB } from './lib/chips'

function App() {
    const [connected, setConnected] = useState(false)
    const [log, setLog] = useState<string[]>([])
    const [selectedChip, setSelectedChip] = useState<ChipDef>(CHIP_DB[0])
    const [memoryData, setMemoryData] = useState<Uint8Array>(new Uint8Array(256).fill(0xFF))
    const [progress, setProgress] = useState(0)
    const [isBusy, setIsBusy] = useState(false)
    const [mode, setMode] = useState<'I2C' | 'SPI' | 'AVR' | 'STM32'>('I2C')

    // OPUP Client Instance - lazy initialization
    const transportRef = useRef<WebSerialTransport>();
    const clientRef = useRef<OPUPClient>();

    if (!transportRef.current) transportRef.current = new WebSerialTransport();
    if (!clientRef.current) clientRef.current = new OPUPClient(transportRef.current);

    useEffect(() => {
        const handleData = (e: Event) => {
            const customEvent = e as CustomEvent;
            const { cmd, payload } = customEvent.detail;
            const payloadHex = Array.from(payload).map((b: any) => b.toString(16).padStart(2, '0').toUpperCase()).join(' ');
            setLog(prev => [...prev.slice(-49), `RX: CMD = ${ cmd.toString(16).toUpperCase() } LEN = ${ payload.length } DATA = ${ payloadHex } `]);
        };
        window.addEventListener('serial-data', handleData);
        return () => window.removeEventListener('serial-data', handleData);
    }, []);

    // Auto-select appropriate chip when mode changes
    useEffect(() => {
        const firstChipForMode = CHIP_DB.find(c => {
            if (mode === 'I2C') return c.type === 'I2C';
            if (mode === 'SPI') return c.type === 'SPI';
            if (mode === 'AVR') return c.type === 'AVR';
            if (mode === 'STM32') return c.type === 'STM32';
            return false;
        });

        if (firstChipForMode && selectedChip.type !== firstChipForMode.type) {
            setSelectedChip(firstChipForMode);
            setMemoryData(new Uint8Array(firstChipForMode.size).fill(0xFF));
        }
    }, [mode]);

    const handleConnect = async () => {
        if (connected) {
            await serialManager.disconnect()
            setConnected(false)
            setLog(prev => [...prev.slice(-49), 'System Disconnected'])
        } else {
            const success = await serialManager.connect()
            if (success) {
                setConnected(true)
                setLog(prev => [...prev.slice(-49), 'System Connected'])
            }
        }
    }

    const handleScanI2C = async () => {
        if (!connected || isBusy) return
        setIsBusy(true)
        setLog(prev => [...prev.slice(-49), 'Scanning I2C Bus...'])

        try {
            const response = await serialManager.sendCommand(CMD.I2C_SCAN);
            const count = response[0];
            if (count === 0) {
                setLog(prev => [...prev.slice(-49), 'I2C Scan: No devices found']);
            } else {
                const addresses = Array.from(response.slice(1, 1 + count));
                const addressStrings = addresses.map(a => '0x' + a.toString(16).toUpperCase().padStart(2, '0'));
                setLog(prev => [...prev.slice(-49), `I2C Scan: Found ${ count } devices: ${ addressStrings.join(', ') } `]);

                // Auto-select chip if a known I2C EEPROM is detected
                if (addresses.includes(0x50) || addresses.includes(0x51) || addresses.includes(0x52)) {
                    const detectedChip = CHIP_DB.find(c => c.name === '24C02');
                    if (detectedChip && selectedChip.name !== detectedChip.name) {
                        setSelectedChip(detectedChip);
                        setLog(prev => [...prev.slice(-49), `Auto - selected: ${ detectedChip.name } (0x50)`]);
                    }
                }
            }
        } catch (err) {
            console.error(err)
            setLog(prev => [...prev.slice(-49), `I2C Scan Failed: ${ err } `])
        } finally {
            setIsBusy(false)
        }
    }

    const handleScanSPI = async () => {
        if (!connected || isBusy) return
        setIsBusy(true)
        setLog(prev => [...prev.slice(-49), 'Scanning SPI Bus...'])

        try {
            const response = await serialManager.sendCommand(CMD.SPI_SCAN);
            const count = response[0];
            if (count === 0) {
                setLog(prev => [...prev.slice(-49), 'SPI Scan: No flash chip detected']);
            } else {
                const mfgID = response[1];
                const devID = (response[2] << 8) | response[3];
                setLog(prev => [...prev.slice(-49), `SPI Scan: Found chip - Mfg: 0x${ mfgID.toString(16).padStart(2, '0') } Dev: 0x${ devID.toString(16).padStart(4, '0') } `]);

                // Auto-detect Winbond W25QXX chips (Manufacturer ID: 0xEF)
                if (mfgID === 0xEF) {
                    // Device ID matching for common Winbond chips
                    if ((devID & 0xFF00) === 0x40) {
                        const sizeCode = devID & 0xFF;
                        const sizeMap: Record<number, string> = {
                            0x15: 'W25Q16', 0x16: 'W25Q32', 0x17: 'W25Q64',
                            0x18: 'W25Q128', 0x19: 'W25Q256'
                        };
                        const chipName = sizeMap[sizeCode];
                        if (chipName) {
                            const detectedChip = CHIP_DB.find(c => c.name === chipName);
                            if (detectedChip) {
                                if (selectedChip.name !== detectedChip.name) {
                                    setSelectedChip(detectedChip);
                                    setLog(prev => [...prev.slice(-49), `Auto - selected: ${ detectedChip.name } (Winbond)`]);
                                }
                            }
                        }
                    }
                }
            }
        } catch (err) {
            console.error(err)
            setLog(prev => [...prev.slice(-49), `SPI Scan Failed: ${ err } `])
        } finally {
            setIsBusy(false)
        }
    }

    const handleRead = async () => {
        if (!connected || isBusy) return

        if (mode === 'AVR') {
            setIsBusy(true)
            setProgress(0)
            setLog(prev => [...prev.slice(-49), `Reading AVR Flash...`])
            try {
                // Enter Prog Mode
                await serialManager.sendCommand(CMD.ISP_ENTER);

                const newData = new Uint8Array(selectedChip.size);
                // Read Flash Loop
                // Cmd: 0x20 (Low Byte), 0x28 (High Byte)
                for (let i = 0; i < selectedChip.size; i++) {
                    const isHigh = i % 2 !== 0;
                    const addr = i >> 1;
                    const op = isHigh ? 0x28 : 0x20;

                    const cmd = new Uint8Array([op, (addr >> 8) & 0xFF, addr & 0xFF, 0x00]);
                    const resp = await serialManager.sendCommand(CMD.ISP_XFER, cmd);
                    newData[i] = resp[3]; // Data is in last byte

                    if (i % 256 === 0) {
                        setProgress(Math.round((i / selectedChip.size) * 100));
                        await new Promise(r => setTimeout(r, 0));
                    }
                }

                await serialManager.sendCommand(CMD.ISP_EXIT);
                setMemoryData(newData);
                setLog(prev => [...prev.slice(-49), 'AVR Read Complete']);
            } catch (err) {
                console.error(err);
                setLog(prev => [...prev.slice(-49), `AVR Read Failed: ${ err } `]);
            } finally {
                setIsBusy(false);
                setProgress(0);
            }
            return;
        }

        if (mode === 'STM32') {
            setIsBusy(true)
            setProgress(0)
            setLog(prev => [...prev.slice(-49), `Reading STM32 Flash...`])
            try {
                // Init SWD
                await serialManager.sendCommand(CMD.SWD_INIT);

                // Configure MEM-AP (CSW) - Size 32-bit, Auto-increment
                // AP 0, Addr 0x00 (CSW) -> 0x23000052 (Size 32, Inc Single)
                // Write AP: [AP:1][Addr:4][Data:4]
                const csw = new Uint8Array([0, 0x00, 0x00, 0x00, 0x00, 0x52, 0x00, 0x00, 0x23]);
                await serialManager.sendCommand(CMD.SWD_WRITE, csw);

                const newData = new Uint8Array(selectedChip.size);
                const baseAddr = 0x08000000; // Flash Base

                for (let i = 0; i < selectedChip.size; i += 4) {
                    const addr = baseAddr + i;

                    // Write TAR (Transfer Address Register) - AP 0, Addr 0x04
                    const tar = new Uint8Array([0, 0x04, 0x00, 0x00, 0x00, addr & 0xFF, (addr >> 8) & 0xFF, (addr >> 16) & 0xFF, (addr >> 24) & 0xFF]);
                    await serialManager.sendCommand(CMD.SWD_WRITE, tar);

                    // Read DRW (Data Read/Write) - AP 0, Addr 0x0C
                    // Read AP: [AP:1][Addr:4]
                    const drw = new Uint8Array([0, 0x0C, 0x00, 0x00, 0x00]);
                    const resp = await serialManager.sendCommand(CMD.SWD_READ, drw);

                    // Response is 4 bytes (Little Endian)
                    newData[i] = resp[0];
                    newData[i + 1] = resp[1];
                    newData[i + 2] = resp[2];
                    newData[i + 3] = resp[3];

                    if (i % 256 === 0) {
                        setProgress(Math.round((i / selectedChip.size) * 100));
                        await new Promise(r => setTimeout(r, 0));
                    }
                }

                setMemoryData(newData);
                setLog(prev => [...prev.slice(-49), 'STM32 Read Complete']);
            } catch (err) {
                console.error(err);
                setLog(prev => [...prev.slice(-49), `STM32 Read Failed: ${ err } `]);
            } finally {
                setIsBusy(false);
                setProgress(0);
            }
            return;
        }

        // Existing I2C/SPI Read Logic
        setIsBusy(true)
        setProgress(0)
        setLog(prev => [...prev.slice(-49), `Reading ${ selectedChip.name }...`])

        try {
            const newData = new Uint8Array(selectedChip.size)
            const chunkSize = 64 // Max payload size

            // For demo purposes, if chip is large, we might want to read less or optimize
            // But with virtualized HexEditor, we can handle it.

            for (let i = 0; i < selectedChip.size; i += chunkSize) {
                const len = Math.min(chunkSize, selectedChip.size - i);

                const payload = new Uint8Array(3);
                payload[0] = selectedChip.address || 0x50;
                payload[1] = len & 0xFF;
                payload[2] = (len >> 8) & 0xFF;

                const response = await serialManager.sendCommand(CMD.I2C_READ, payload);

                if (response.length === len) {
                    newData.set(response, i);
                } else {
                    throw new Error("Invalid response length");
                }

                setProgress(Math.round(((i + chunkSize) / selectedChip.size) * 100))

                // Yield to UI loop occasionally
                if (i % (chunkSize * 10) === 0) await new Promise(r => setTimeout(r, 0));
            }

            setMemoryData(newData)
            setLog(prev => [...prev.slice(-49), 'Read Complete'])
        } catch (err) {
            console.error(err)
            setLog(prev => [...prev.slice(-49), 'Read Failed'])
        } finally {
            setIsBusy(false)
            setProgress(0)
        }
    }

    const handleWrite = async () => {
        if (!connected || isBusy) return

        if (mode === 'AVR') {
            setIsBusy(true)
            setProgress(0)
            setLog(prev => [...prev.slice(-49), `Writing AVR Flash...`])
            try {
                // Enter Prog Mode
                await serialManager.sendCommand(CMD.ISP_ENTER);

                // Page Write Loop
                const pageSize = selectedChip.pageSize;
                for (let i = 0; i < memoryData.length; i += pageSize) {
                    const pageAddr = i >> 1; // Word address

                    // Load Page Buffer
                    for (let j = 0; j < pageSize; j += 2) {
                        const wordAddr = j >> 1;
                        const byteLow = memoryData[i + j];
                        const byteHigh = memoryData[i + j + 1] || 0xFF;

                        // Load Low Byte
                        await serialManager.sendCommand(CMD.ISP_XFER, new Uint8Array([0x40, 0x00, wordAddr & 0xFF, byteLow]));
                        // Load High Byte
                        await serialManager.sendCommand(CMD.ISP_XFER, new Uint8Array([0x48, 0x00, wordAddr & 0xFF, byteHigh]));
                    }

                    // Write Page
                    await serialManager.sendCommand(CMD.ISP_XFER, new Uint8Array([0x4C, (pageAddr >> 8) & 0xFF, pageAddr & 0xFF, 0x00]));
                    await new Promise(r => setTimeout(r, 10)); // Wait for write

                    setProgress(Math.round(((i + pageSize) / memoryData.length) * 100));
                    await new Promise(r => setTimeout(r, 0));
                }

                await serialManager.sendCommand(CMD.ISP_EXIT);
                setLog(prev => [...prev.slice(-49), 'AVR Write Complete']);
            } catch (err) {
                console.error(err);
                setLog(prev => [...prev.slice(-49), `AVR Write Failed: ${ err } `]);
            } finally {
                setIsBusy(false);
                setProgress(0);
            }
            return;
        }

        if (mode === 'STM32') {
            setIsBusy(true)
            setProgress(0)
            setLog(prev => [...prev.slice(-49), `Writing STM32 RAM(Test)...`])
            try {
                // Init SWD
                await serialManager.sendCommand(CMD.SWD_INIT);

                // Configure MEM-AP (CSW) - Size 32-bit, Auto-increment
                const csw = new Uint8Array([0, 0x00, 0x00, 0x00, 0x00, 0x52, 0x00, 0x00, 0x23]);
                await serialManager.sendCommand(CMD.SWD_WRITE, csw);

                const baseAddr = 0x20000000; // RAM Base
                const testSize = 256; // Write first 256 bytes for test

                for (let i = 0; i < testSize; i += 4) {
                    const addr = baseAddr + i;

                    // Write TAR
                    const tar = new Uint8Array([0, 0x04, 0x00, 0x00, 0x00, addr & 0xFF, (addr >> 8) & 0xFF, (addr >> 16) & 0xFF, (addr >> 24) & 0xFF]);
                    await serialManager.sendCommand(CMD.SWD_WRITE, tar);

                    // Write DRW
                    const val = memoryData[i] | (memoryData[i + 1] << 8) | (memoryData[i + 2] << 16) | (memoryData[i + 3] << 24);
                    const drw = new Uint8Array([0, 0x0C, 0x00, 0x00, 0x00, val & 0xFF, (val >> 8) & 0xFF, (val >> 16) & 0xFF, (val >> 24) & 0xFF]);
                    await serialManager.sendCommand(CMD.SWD_WRITE, drw);

                    if (i % 64 === 0) {
                        setProgress(Math.round((i / testSize) * 100));
                        await new Promise(r => setTimeout(r, 0));
                    }
                }

                setLog(prev => [...prev.slice(-49), 'STM32 RAM Write Complete (256B)']);
            } catch (err) {
                console.error(err);
                setLog(prev => [...prev.slice(-49), `STM32 Write Failed: ${ err } `]);
            } finally {
                setIsBusy(false);
                setProgress(0);
            }
            return;
        }

        // Existing I2C/SPI Write Logic
        setIsBusy(true)
        setProgress(0)
        setLog(prev => [...prev.slice(-49), `Writing ${ memoryData.length } bytes to ${ selectedChip.name }...`])

        try {
            const chunkSize = selectedChip.pageSize || 16; // Use chip's page size

            for (let i = 0; i < memoryData.length; i += chunkSize) {
                const len = Math.min(chunkSize, memoryData.length - i);

                // Payload: [I2C_Addr][Data...]
                const payload = new Uint8Array(1 + len);
                payload[0] = selectedChip.address || 0x50;
                payload.set(memoryData.slice(i, i + len), 1);

                await serialManager.sendCommand(CMD.I2C_WRITE, payload);

                // Wait for EEPROM write cycle (typically 5-10ms)
                await new Promise(r => setTimeout(r, 10));

                setProgress(Math.round(((i + chunkSize) / memoryData.length) * 100))

                // Yield to UI occasionally
                if (i % (chunkSize * 10) === 0) await new Promise(r => setTimeout(r, 0));
            }

            setLog(prev => [...prev.slice(-49), 'Write Complete'])
        } catch (err) {
            console.error(err)
            setLog(prev => [...prev.slice(-49), `Write Failed: ${ err } `])
        } finally {
            setIsBusy(false)
            setProgress(0)
        }
    }

    const handleVerify = async () => {
        if (!connected || isBusy) return
        setIsBusy(true)
        setProgress(0)
        setLog(prev => [...prev.slice(-49), `Verifying ${ selectedChip.name }...`])

        try {
            const chunkSize = 64;
            let errors = 0;

            for (let i = 0; i < memoryData.length; i += chunkSize) {
                const len = Math.min(chunkSize, memoryData.length - i);

                const payload = new Uint8Array(3);
                payload[0] = selectedChip.address || 0x50;
                payload[1] = len & 0xFF;
                payload[2] = (len >> 8) & 0xFF;

                const response = await serialManager.sendCommand(CMD.I2C_READ, payload);

                // Compare with current memory
                for (let j = 0; j < len; j++) {
                    if (response[j] !== memoryData[i + j]) {
                        errors++;
                        setLog(prev => [...prev.slice(-49), `Mismatch at 0x${ (i + j).toString(16) }: expected 0x${ memoryData[i + j].toString(16).padStart(2, '0') }, got 0x${ response[j].toString(16).padStart(2, '0') } `]);
                    }
                }

                setProgress(Math.round(((i + chunkSize) / memoryData.length) * 100))

                if (i % (chunkSize * 10) === 0) await new Promise(r => setTimeout(r, 0));
            }

            if (errors === 0) {
                setLog(prev => [...prev.slice(-49), 'Verify Complete: All bytes match âœ“'])
            } else {
                setLog(prev => [...prev.slice(-49), `Verify Failed: ${ errors } mismatches found`])
            }
        } catch (err) {
            console.error(err)
            setLog(prev => [...prev.slice(-49), `Verify Failed: ${ err } `])
        } finally {
            setIsBusy(false)
            setProgress(0)
        }
    }

    const handleErase = async () => {
        if (!connected || isBusy) return

        if (mode === 'AVR') {
            // AVR Chip Erase
            setIsBusy(true)
            setLog(prev => [...prev.slice(-49), `Erasing AVR Chip...`])
            try {
                // Send Chip Erase command (0xAC, 0x80, 0x00, 0x00)
                const cmd = new Uint8Array([0xAC, 0x80, 0x00, 0x00]);
                await serialManager.sendCommand(CMD.ISP_XFER, cmd);
                await new Promise(r => setTimeout(r, 50)); // Wait for erase
                setLog(prev => [...prev.slice(-49), 'AVR Chip Erase Complete'])
                // Clear memory view
                setMemoryData(new Uint8Array(selectedChip.size).fill(0xFF))
            } catch (err) {
                console.error(err)
                setLog(prev => [...prev.slice(-49), `AVR Erase Failed: ${ err } `])
            } finally {
                setIsBusy(false)
            }
            return;
        }

        if (mode === 'STM32') {
            setLog(prev => [...prev.slice(-49), `STM32 Erase Not Implemented Yet`])
            return;
        }

        // I2C/SPI Erase Logic (Existing)
        setIsBusy(true)
        setProgress(0)
        setLog(prev => [...prev.slice(-49), `Erasing ${ selectedChip.name } (filling with 0xFF)...`])

        try {
            const chunkSize = selectedChip.pageSize || 16;
            const eraseData = new Uint8Array(chunkSize).fill(0xFF);

            for (let i = 0; i < selectedChip.size; i += chunkSize) {
                const len = Math.min(chunkSize, selectedChip.size - i);

                const payload = new Uint8Array(1 + len);
                payload[0] = selectedChip.address || 0x50;
                payload.set(eraseData.slice(0, len), 1);

                await serialManager.sendCommand(CMD.I2C_WRITE, payload);
                await new Promise(r => setTimeout(r, 10));

                setProgress(Math.round(((i + chunkSize) / selectedChip.size) * 100))

                if (i % (chunkSize * 10) === 0) await new Promise(r => setTimeout(r, 0));
            }

            // Update local memory view
            setMemoryData(new Uint8Array(selectedChip.size).fill(0xFF))
            setLog(prev => [...prev.slice(-49), 'Erase Complete'])
        } catch (err) {
            console.error(err)
            setLog(prev => [...prev.slice(-49), `Erase Failed: ${ err } `])
        } finally {
            setIsBusy(false)
            setProgress(0)
        }
    }

    const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0]
        if (!file) return

        const reader = new FileReader()
        reader.onload = (e) => {
            const arrayBuffer = e.target?.result as ArrayBuffer
            const data = new Uint8Array(arrayBuffer)

            // Resize or pad to chip size
            const chipData = new Uint8Array(selectedChip.size).fill(0xFF)
            chipData.set(data.slice(0, selectedChip.size))

            setMemoryData(chipData)
            setLog(prev => [...prev.slice(-49), `Loaded ${ data.length } bytes from ${ file.name } `])
        }
        reader.readAsArrayBuffer(file)
    }

    return (
        <div className="min-h-screen bg-slate-950 text-white p-8 font-sans selection:bg-cyan-500/30">
            <div className="max-w-[1600px] mx-auto">
                <Header connected={connected} onConnect={handleConnect} />

                <div className="flex gap-4 mb-6 border-b border-white/10 pb-4">
                    {(['I2C', 'SPI', 'AVR', 'STM32'] as const).map((m) => (
                        <button
                            key={m}
                            onClick={() => setMode(m)}
                            className={`px - 6 py - 2 font - mono font - bold tracking - wider transition - all ${
    mode === m
    ? 'bg-cyan-500/20 text-cyan-400 border border-cyan-500/50'
    : 'text-slate-500 hover:text-slate-300 border border-transparent'
} `}
                        >
                            {m}
                        </button>
                    ))}
                </div>

                <main className="grid grid-cols-1 lg:grid-cols-12 gap-8">
                    <Sidebar
                        mode={mode}
                        selectedChip={selectedChip}
                        onSelectChip={setSelectedChip}
                        connected={connected}
                        isBusy={isBusy}
                        progress={progress}
                        onScanI2C={handleScanI2C}
                        onScanSPI={handleScanSPI}
                        onRead={handleRead}
                        onWrite={handleWrite}
                        onVerify={handleVerify}
                        onErase={handleErase}
                    />

                    <div className="lg:col-span-9 flex flex-col gap-8 h-[calc(100vh-200px)]">
                        <div className="bg-slate-900/80 border border-white/10 rounded-none backdrop-blur-md flex flex-col h-full relative overflow-hidden p-6">
                            <div className="flex justify-between items-center mb-4">
                                <div>
                                    <h2 className="text-lg font-bold text-white font-mono uppercase tracking-wider flex items-center gap-2">
                                        <span className="text-emerald-400">03.</span> Memory Matrix
                                    </h2>
                                    <div className="text-[10px] font-mono text-slate-500 uppercase tracking-widest mt-1">
                                        {memoryData.length.toLocaleString()} BYTES LOADED
                                    </div>
                                </div>
                                <div className="flex gap-3">
                                    <label className="px-4 py-2 bg-blue-600/20 hover:bg-blue-600/30 text-blue-400 border border-blue-500/30 font-mono text-sm font-bold tracking-wider transition-all cursor-pointer">
                                        LOAD FILE
                                        <input type="file" className="hidden" onChange={handleFileUpload} accept=".bin,.hex,.eep" />
                                    </label>
                                    <button
                                        className="px-4 py-2 bg-purple-600/20 hover:bg-purple-600/30 text-purple-400 border border-purple-500/30 font-mono text-sm font-bold tracking-wider transition-all"
                                        onClick={() => {
                                            const blob = new Blob([new Uint8Array(memoryData)], { type: 'application/octet-stream' })
                                            const url = URL.createObjectURL(blob)
                                            const a = document.createElement('a')
                                            a.href = url
                                            a.download = `${ selectedChip.name } _backup.bin`
                                            a.click()
                                            URL.revokeObjectURL(url)
                                            setLog(prev => [...prev.slice(-49), `Saved backup to ${ selectedChip.name } _backup.bin`])
                                        }}
                                    >
                                        SAVE FILE
                                    </button>
                                </div>
                            </div>
                            <div className="flex-1">
                                <HexEditor data={memoryData} />
                            </div>
                        </div>

                        {/* AVR Fuse Bit Editor */}
                        {mode === 'AVR' && (
                            <div className="lg:col-span-12 mt-6">
                                <AVRFuseEditor
                                    connected={connected}
                                    isBusy={isBusy}
                                    onBusyChange={setIsBusy}
                                    onLog={(msg) => setLog(prev => [...prev.slice(-49), msg])}
                                />
                            </div>
                        )}

                        <div className="lg:hidden">
                            <Log logs={log} />
                        </div>
                    </div>

                    <div className="hidden lg:block lg:col-span-3">
                        {/* Spacer or additional sidebar content if needed */}
                    </div>
                    <div className="hidden lg:block lg:col-span-12">
                        <Log logs={log} />
                    </div>
                </main>
            </div>
        </div>
    )
}

export default App

