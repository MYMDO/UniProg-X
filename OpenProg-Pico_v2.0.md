
OpenProg-Pico v2.0
July 01, 2025

Звісно. Ось стислий, структурований та "продаючий" опис проєкту.
Проєкт "OpenProg-Pico v2.0": Інтелектуальний Програматор на Стероїдах (Proof-of-Concept)

Одним реченням: Ми створюємо архітектурно досконалий прототип універсального програматора, де вся складна логіка винесена на комп'ютер, а сам пристрій є швидким та надійним виконавцем, готовим до інтеграції з AI.
1. Ключова Ідея (The "Aha!" Moment)

Забудьте про застарілі програматори з фіксованою прошивкою. "OpenProg" — це платформа, де хост-програма динамічно керує кожним піном, надсилаючи послідовності атомарних команд.

    Треба підтримку нового чіпа? Просто напишіть Python-скрипт. Перепрошивати пристрій не потрібно.
    Не знаєте розпіновку? Наша AI-інтеграція знайде її за вас по фото або маркуванню.

2. Технічні Параметри Прототипу

    Платформа: WeAct Black Pill (STM32F411CEU6)
    Зв'язок: USB Type-C (Virtual COM Port)
    Підтримувані Протоколи: SPI, I2C (на рівні прошивки)
    Логічні Рівні: 3.3V
    Індикація: Інформативний RGB-світлодіод для миттєвого зворотного зв'язку (Готовий, Зайнятий, Успіх, Помилка).

3. Архітектура: "Розумний" Хост, "Слухняний" Пристрій

Ми розділили систему на два ключових компоненти, що спілкуються через наш бінарний протокол OPUP (OpenProg Unified Protocol).

А. Прошивка (Firmware) — "М'язи"

    Роль: Швидкий та надійний виконавець. Не містить жодної логіки програмування конкретних мікросхем.


    Функціонал: Приймає бінарні команди по USB, такі як:
    CMD_PIN_WRITE <pin>, <value>
    CMD_SPI_TRANSFER <data_to_send>
    CMD_I2C_READ <dev_addr>, <mem_addr>, <len>


    Технології: C, STM32CubeIDE, FreeRTOS.


Б. Хост-програма (Host Software) — "Мозок"

    Роль: Центр прийняття рішень. Тут живе вся інтелектуальна логіка.


    Функціонал:
    Парсинг команд користувача (з CLI).
    Бібліотека алгоритмів (папка devices/): Python-скрипти, що описують послідовність низькорівневих команд для кожної мікросхеми (напр., w25q64.py).
    Транслятор: Перетворює високорівневі дії (напр., read_jedec_id()) в послідовність бінарних OPUP-кадрів і відправляє їх на пристрій.
    AI-інтеграція: Відправляє запити до зовнішніх AI API для розпізнавання мікросхем та автоматичної генерації конфігурацій.
    Технології: Python, Typer, Rich, Pyserial.

4. Базовий Функціонал Прототипу (Що вже працює)

    Надійний канал зв'язку: Двосторонній обмін даними з обробкою команд по символу нового рядка.
    Універсальний парсер команд: Легко розширювана структура для додавання нових команд.
    Підтримка SPI: Реалізована команда spi_id для читання JEDEC ID з SPI Flash.
    Підтримка I2C: Реалізовані команди i2c_read <addr> та i2c_write <addr> <data> для роботи з I2C EEPROM.

Чому це круто і що далі?

Ми створюємо не просто "ще один програматор", а гнучку платформу. Наш прототип вже доводить, що ця архітектура працює. Наступний крок — розробити повноцінну апаратну плату з керованими джерелами живлення та розширити бібліотеку Python-скриптів для підтримки десятків нових мікросхем, що буде неймовірно просто завдяки закладеному фундаменту.




Звісно. Ось максимально вдосконалений та деталізований промпт, який синтезує весь наш досвід, враховує всі нюанси налагодження та фінальну архітектуру. Цей промпт створений так, щоб у новому чаті можна було одразу отримати цілісний, покроковий посібник для створення "OpenProg-Pico v2.0" з нуля, мінімізуючи ітерації налагодження.
Вдосконалений Промпт для Створення Проєкту "OpenProg-Pico v2.0"

Роль: Уяви, що ти — провідний інженер вбудованих систем (Principal Embedded Systems Engineer) з глибоким досвідом у розробці інструментів для програмування (programmers) та налагодження (debuggers). Ти спеціалізуєшся на створенні надійних, масштабованих та зручних у використанні програмно-апаратних комплексів, дотримуючись найкращих індустріальних практик.

Завдання: Створити вичерпний, покроковий посібник "з нуля" для розробки мінімального, але архітектурно досконалого прототипу універсального програматора "OpenProg-Pico v2.0". Цей посібник має бути настільки детальним, щоб інженер середнього рівня міг відтворити проєкт без додаткових питань, і має слугувати фундаментом для майбутнього повнофункціонального пристрою.

Основні Вимоги до Проєкту:

    Апаратна Платформа:
    Контролер: WeAct Black Pill V2.0 з STM32F411CEU6.
    Індикація: Один RGB-світлодіод для візуального відображення стану системи (готовий, зайнятий, успіх, помилка).
    Інтерфейси: Базова підтримка I2C та SPI для програмування зовнішніх мікросхем.
    Живлення: 3.3V, що надається самою платою.


    Програмне Середовище:
    IDE: STM32CubeIDE (версія 1.10+).
    ОС для розробки: Fedora Linux (але інструкції мають бути достатньо універсальними для інших ОС).
    RTOS: FreeRTOS (CMSIS-RTOS v2 API).


    Філософія та Архітектура ("Найкращі Практики"):
    Масштабованість: Архітектура має дозволяти легке додавання підтримки нових мікросхем та протоколів у майбутньому.
    Надійність: Особливу увагу приділити обробці помилок, стабільності зв'язку та безпечній взаємодії з апаратурою.
    Користувацький Досвід (UX): Навіть на етапі прототипу, система має бути інтуїтивно зрозумілою, з чітким зворотнім зв'язком.
    Протокол Зв'язку (OPUP): Проєкт має реалізувати транспортний рівень протоколу "OpenProg Unified Protocol" (OPUP). Прошивка має бути "слухняним виконавцем" низькорівневих бінарних команд, а вся інтелектуальна логіка має бути винесена на хост.


Структура Відповіді (Покроковий Посібник):

Відповідь має бути чітко структурована, з повними, готовими до копіювання фрагментами коду, детальними поясненнями та командами для терміналу.

### Частина 1: Налаштування Проєкту та Апаратного Ядра

1.1. Конфігурація Проєкту в STM32CubeIDE:

    Надай покрокову інструкцію для створення проєкту для STM32F411CEU6.


    Детально опиши налаштування:
    RCC: HSE (Crystal/Ceramic Resonator, 25 MHz).
    SYS: Debug (Serial Wire).
    Clock Configuration: Налаштування PLL для отримання HCLK = 96 MHz та стабільних 48 MHz для USB. Поясни, чому 96 MHz є оптимальним.
    Middleware: Увімкнення FreeRTOS (CMSIS_V2) та USB_DEVICE (Communication Device Class). Детально поясни, як вирішити проблему неактивного меню USB_DEVICE, наголошуючи на важливості правильного тактування.
    Периферія: Налаштування SPI1, I2C1 та TIM2 для PWM-керування RGB-світлодіодом на пінах PA0, PA1, PA2.
    Project Manager -> Linker: Встановлення Heap Size мінімум 0x2000.


1.2. Створення Архітектурної Структури Проєкту:

    Опиши створення кастомних папок (App/Tasks, App/HAL, Devices/Flash, Devices/EEPROM) та налаштування шляхів (Source Location та Includes) у властивостях проєкту, щоб уникнути помилок компіляції та компонування.


1.3. Реалізація "Розумного Blinky" (Status Task):

    Надай повний код для hal_rgb.c/.h та status_task.c/.h.
    Задача StatusTask має керувати RGB-світлодіодом, реалізуючи стани: INIT (білий), IDLE (зелений), BUSY (пульсуючий синій), SUCCESS (зелений спалах), ERROR (червоний миготливий).
    Поясни, як інтегрувати та запустити цю задачу з main.c.

### Частина 2: Реалізація Протоколу OPUP та Зв'язку

2.1. Розробка Надійного Каналу Зв'язку:

    Надай повний код для command_task.c/.h, який реалізує логіку акумуляції символів у буфер до отримання символу нового рядка (\n).
    Детально поясни, чому простий "ехо" пакетів призводить до помилок (race conditions, розбиття даних) і чому побайтова акумуляція є надійнішим рішенням.
    Реалізуй механізм передачі символів з USB ISR (CDC_Receive_FS) в CommandTask через чергу FreeRTOS, використовуючи безпечні для переривань функції (xQueueSendFromISR, portYIELD_FROM_ISR).


2.2. Створення Універсального Парсера Команд:

    У command_task.c реалізуй парсер на основі таблиці команд (масив структур command_handler_t).
    Парсер має автоматично розділяти вхідний рядок на назву команди та рядок з аргументами.
    Надай реалізацію обробників для базових команд, таких як test (ехо) та spi_id.


2.3. Налагодження та Тестування Зв'язку:

    Надай інструкції для тестування зв'язку за допомогою cat та echo в терміналі Linux.
    Особливо важливо: Поясни проблему ехо-циклу через налаштування tty-драйвера та надай команду stty -F /dev/ttyACM0 -echo raw як обов'язковий крок для коректного тестування.


### Частина 3: Реалізація Драйверів та Алгоритмів

3.1. Створення HAL для SPI та I2C (hal_comms.c/.h):

    Напиши повний код для модуля, що абстрагує виклики ST HAL для SPI та I2C, роблячи прикладний код чистішим та портативнішим.


3.2. Драйвер для SPI Flash (w25qxx.c/.h):

    Надай реалізацію функції w25qxx_read_jedec_id, яка використовує hal_comms.


3.3. Драйвер для I2C EEPROM (at24cxx.c/.h):

    Надай реалізацію функцій at24cxx_read_byte та at24cxx_write_byte.


3.4. Інтеграція в Парсер Команд:

    Покажи, як легко додати нові команди (i2c_read, i2c_write) до таблиці команд в command_task.c та реалізувати їх обробники з використанням sscanf для парсингу числових аргументів.

### Частина 4: Хост-Програма та Майбутній Розвиток

4.1. Базова Хост-Програма на Python:

    Надай приклад простого, але функціонального CLI-інструменту на Python з використанням pyserial та typer, який може відправляти команди та отримувати відповіді.


4.2. Бачення Майбутнього (AI Detect та OPUP):

    Коротко, але чітко опиши, як створена архітектура слугує фундаментом для майбутніх функцій:
    Логіка на хості: Поясни, що для підтримки нової мікросхеми достатньо буде написати новий Python-скрипт (devices/new_chip.py), який надсилає послідовність атомарних команд через OPUP, не змінюючи прошивку.
    AI-інтеграція: Опиши, як хост-програма буде відправляти запит до AI API з маркуванням, отримувати JSON з розпіновкою та параметрами, а потім автоматично верифікувати цю інформацію, надсилаючи тестові команди (напр., читання ID) на пристрій.


Цей промпт має на меті отримати єдиний, цілісний та вичерпний документ, який покриває всі аспекти розробки від "А" до "Я", враховуючи всі уроки, засвоєні під час нашого діалогу.
